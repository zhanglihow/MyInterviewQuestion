# 算法篇

### 1，一个整数转换为二进制后，1的个数

```
public int countA(int n){  
   int res = 0;  
   while(n != 0){  
       n &= (n - 1);  
       res++;  
   }  
   return res;
} 
```

### 2，给定一个整数，请写一个函数判断该整数的奇偶性

二进制中如果 一个数是偶数那么最后一个一定是 0 如果一个数是奇数那么最后一位一定是 1；而十进制 1 在 8 位二进制中表示为 0000 0001，我们只需将一个数个 1相与（&） 得到的结果如果是 1 则表示该数为奇数，否知为偶数。

```
public boolean isOdd(int num){
    return num & 1 != 0;
}
```

### 3，同样给定一个整数，请写一个函数判断该整数是不是2的整数次幂

一个二进制如果表示为 0..0100…0，那么它减去1得到的数二进制表示肯定是 0..0011..1 的形式。那么这个数与自自己减一后的数相与得到结果肯定为0。

```
8   0000 1000      7   0000 0111
7 & 0000 0111      6 & 0000 0110
-------------      -------------
0   0000 0000      6   0000 0110

public boolean log2(int num){
   return (num & (num - 1)) == 0;
}
```

### 4，在其他数都出现两次的数组中找到只出现一次的那个数

首先我们应该知道二进制异或操作，异或结果是二进制中两个位相同为0，相异为1。因此可以有个规律：  

```
任何整数 n 与 0 异或总等于其本身 n，一个数与其本身异或那么结果肯定是 0。
```

假设有这么一个序列： C B D A A B C 其中只有 D 出现一次，那么因为异或满足交换律和结合律，所以我们遍历异或此序列的过程等价于  

```
eO ^ (A ^ A ^ B ^ B ^ C ^ C ) ^ D = eO ^ 0 ^ D = D
```

所以对于任何排列的数组，如果只有一个数只出现了奇数次，其他的数都出现了欧数次，那么最终异或的结果肯定为出现奇数次的那个数。  

```
public int oddTimesNum(int[] arr) {
   int eO = 0;
   for (int cur : arr) {
       eO = eO ^ cur;
   }

   return eO;
}
```

### 5，在其他数都出现两次的数组中找到只出现一次的那两个数

```
public void printOddTimesNum(int[] arr) {
   int eO = 0;
   int eOhasOne = 0;

   for (int cur : arr) {
       eO = eO ^ cur;
   }

   int rightOne = eO & (~eO + 1);
   for (int cur : arr) {
       if ((rightOne & cur) != 0) {
           eOhasOne = eOhasOne ^ cur;
       }
   }

   System.out.println("eOhasOne = " + eOhasOne + "  " + (eOhasOne ^ eO));
}
```

### 6，数组A内容为 1,2,3,4...52 ,数组B内容为26个英文字母，使用两个线程分别输入两个数组，打印内容为：12a34b56c78e.......

```
import java.util.concurrent.atomic.AtomicBoolean;

public class PrintNumAndChar1 {

    public static void main(String[] args) {
        AtomicBoolean isNum = new AtomicBoolean(true);
        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        char[] chars = { 'a', 'b', 'c', 'd', 'e' };
        new PrintNums(nums, isNum).start();
        new PrintChars(chars, isNum).start();

    }

    public static class PrintNums extends Thread {
        private int[] nums;
        private AtomicBoolean isNum;

        public PrintNums(int[] a1, AtomicBoolean isNum) {
            this.nums = a1;
            this.isNum = isNum;
        }

        public void run() {
            int count = 0;
            for (int i = 0; i < nums.length; i++) {
                while (!isNum.get()) {
                    Thread.yield();
                }
                System.out.print(nums[i]);
                count++;
                if (count == 2) {
                    isNum.set(false);
                    count = 0;
                }
            }
            isNum.set(false);
        }
    }

    public static class PrintChars extends Thread {
        private char[] chars;
        private AtomicBoolean isNum;

        public PrintChars(char[] a2, AtomicBoolean isNum) {
            this.chars = a2;
            this.isNum = isNum;
        }

        public void run() {
            int count = 0;
            for (int i = 0; i < chars.length; i++) {
                while (isNum.get()) {
                    Thread.yield();
                }
                System.out.print(chars[i]);
                count++;
                if (count == 1) {
                    isNum.set(true);
                    count = 0;
                }
            }
            isNum.set(true);
        }
    }
}
```

```
    public void test2() {
        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        char[] chars = { 'a', 'b', 'c', 'd', 'e' };
        StringBuffer strs=new StringBuffer();
        PrintNums1 t1 = new PrintNums1(nums,strs);
        PrintChars1 t2 = new PrintChars1(chars,strs);
        t1.setPrintChars(t2);
        t2.setPrintNums(t1);
        t1.start();
        t2.start();
    }

    public static class PrintNums1 extends Thread {
        private int[] nums;
        private PrintChars1 printChars;
        private StringBuffer strs;

        public PrintNums1(int[] a1,StringBuffer strs) {
            super();
            this.nums = a1;
            this.strs=strs;
        }

        public void setPrintChars(PrintChars1 printChars) {
            this.printChars = printChars;
        }

        public void run() {
            int count = 0;
            for (int i = 0; i < nums.length; i++) {
                if(count==2){
                    count = 0;
                    LockSupport.unpark(printChars);
                    LockSupport.park();
                }
                strs=strs.append(nums[i]);
                System.out.println(strs);
                count++;
            }
            LockSupport.unpark(printChars);
        }
    }

    public static class PrintChars1 extends Thread {
        private char[] chars;
        private PrintNums1 printNums;
        private StringBuffer strs;

        public PrintChars1(char[] chars,StringBuffer strs) {
            super();
            this.chars = chars;
            this.strs=strs;
        }

        public void setPrintNums(PrintNums1 printNums) {
            this.printNums = printNums;
        }

        public void run() {
            LockSupport.park();
            int count = 0;
            for (int i = 0; i < chars.length; i++) {
                if(count==1){
                    count = 0;
                    LockSupport.unpark(printNums);
                    LockSupport.park();
                }
                strs=strs.append(chars[i]);
                System.out.println(strs);
                count++;
            }
            LockSupport.unpark(printNums);
        }
    }
```



